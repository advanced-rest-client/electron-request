# Electron request

A HTTP client for Advanced REST client.

It works in the renderer process and allows to make a HTTP request resulting with detailed response.

The detailed response contains information about redirects and timings similar to the ones presented by Chrome Dev Tools.

The response object generated by this library works with `@advanced-rest-client/response-view`.

## Usage

The library contain two HTTP clients:
-   SocketRequest - ARC's original and own HTTP client. Operates directly on the socket.
-   ElectronRequest - A request engine using higher level Node's APIs

Both classes use the same configuration and produce the same output.

### Installation

```sh
npm i -S @advanced-rest-client/electron-request
```

### Socket request

Originally `SocketRequest` was develop for ARC Chrome Application as Chrome apps don't have access to low level
request APIs and therefore the application was unable to produce detailed information about the request.

```javascript
import { SocketRequest } from '@advanced-rest-client/electron-request';

const opts = {
  timeout: 30000,
  hosts: [{from: 'domain.com', to: 'other.com'}],
  followRedirects: true
};

const request = {
  id: 'some-id',
  url: 'http://api.domain.com',
  method: 'GET',
  headers: 'x-test: true'
};

const connection = new SocketRequest(request, opts);
request.on('load', (response, request) => {});
request.on('error', (error) => {});
try {
  await connection.send();
  console.log('Request message sent.');
} catch (cause) {
  // usually it means that the server is down or configuration is invalid (URL).
  console.error('Connection error', cause);
}
```

### Native request

Electron application can access Node's APIs and therefore `SocketRequest` can be eventually replaced to reduce amount of code to maintain.

```javascript
import { ElectronRequest } from '@advanced-rest-client/electron-request';

const opts = {
  timeout: 30000,
  hosts: [{from: 'domain.com', to: 'other.com'}],
  followRedirects: true
};

const request = {
  id: 'some-id',
  url: 'http://api.domain.com',
  method: 'GET',
  headers: 'x-test: true'
};

const connection = new ElectronRequest(request, opts);
request.on('load', (id, response, request) => {});
request.on('error', (error, id) => {});
try {
  await connection.send();
  console.log('Request message sent.');
} catch (cause) {
  // usually it means that the server is down or configuration is invalid (URL).
  console.error('Connection error', cause);
}
```

## Request object

### `id`

The request identifier to be used to recognize the request when one of the events is dispatched.
It is used in internally in ARC to support multiple request/response panels.
This can be anything, however, `uuid` string is recommended.

### `url`

**Required**

`String` Request URL. It must be valid URL or otherwise it throws an error.

### `method`

**Required**

`String` Request method.

### `headers`

**Optional**

`String` Request headers string.

### `payload`

**Optional**

`String` or `Buffer` or `Blob` Request payload value.

Note, this field is ignored for `HEAD` and `GET` requests.

## Configuration options

### `validateCertificates`

When set it validates certificates during request.

### `followRedirects`

When false the request object won't follow redirects.

### `timeout`

Request timeout in milliseconds

### `logger`

Logger object. If not set is uses `electron-log`

### `hosts`

Hosts table. Each rule must have `from` and `to` properties.

### `sentMessageLimit`

A limit of characters to include into the `sentHttpMessage` property of the request object. 0 to disable limit. Default to 2048.

### `defaultHeaders`

`Boolean` When set the request adds `accept` and `user-agent` headers if not set on the request.
This way it behaves like cURL command.

### `defaultUserAgent`

`String` Default `user-agent` header to be used with request when `defaultHeaders` is set.
It defaults to `advanced-rest-client`

### `defaulAccept`

`String` Default `accept` header to be used with request when `defaultHeaders` is set.
It defaults to `*/*`

### `clientCertificate`

Adds client certificates to be send with the request.
This implementation supports PFX or PKCS12 encoded private key and certificate chain or PEM cert/key format.

#### clientCertificate struct

| Property | Type | Description |
| --- | --- | --- |
| `type` | `String` | Certificate type. Either `p12` or `pem`. **Required.** |
| `cert` | `Array<Certificate>` or `Cetrificate` | Certificate or list of certificates to use. **Required.** |
| `key` | `Array<Certificate>` or `Cetrificate` | Key for `pem` certificate. **Optional.** |

#### Certificate struct

| Property | Type | Description |
| --- | --- | --- |
| `data` | `String` or `Buffer` | The certificate to use. **Required.** The `p12` type certificate must be a `Buffer`. |
| `passphrase` | `String` | A passphrase to use to unlock the certificate. **Optional.** |

#### Example

##### PKCS12 certificate

```javascript
clientCertificate: {
  // has to be a buffer
  cert: {
    data: fs.readFileSync('./test/cert-auth-server/alice-password.p12'),
    passphrase: 'test',
  },
  type: 'p12',
},
```

##### PEM certificate

```javascript
clientCertificate: {
  // has to be a buffer
  cert: {
    data: fs.readFileSync('./test/cert-auth-server/alice_cert.pem', 'utf8'),
  },
  key: {
    data: fs.readFileSync('./test/cert-auth-server/alice_key.pem', 'utf8'),
  },
  type: 'pem',
},
```

## Running tests

You need [Docker](https://www.docker.com/products/docker-desktop) to run the test as they uses `kennethreitz/httpbin` image.

Run this command to download the image:

```
docker pull kennethreitz/httpbin
```

Then run the image:
```
docker run -d -p 80:80 kennethreitz/httpbin
```

Check if instance is running:

```
docker ps -a
```

This should print something like:

```
CONTAINER ID        IMAGE                      COMMAND                  CREATED             STATUS           PORTS                NAMES
e4bb74785018        kennethreitz/httpbin       "gunicorn -b 0.0.0.0â€¦"   8 seconds ago       Up 6 seconds     0.0.0.0:80->80/tcp   condescending_kalam
```

Run the tests:

```
npm test
```

Finally kill the pod:

```
docker stop e4bb74785018
```
